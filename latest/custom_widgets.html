<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Custom widgets · Interact</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Interact</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="observables.html">Observables</a></li><li><a class="toctext" href="widgets.html">Widgets</a></li><li class="current"><a class="toctext" href="custom_widgets.html">Custom widgets</a><ul class="internal"><li><a class="toctext" href="#The-Widget-type-1">The Widget type</a></li><li><a class="toctext" href="#The-recipe-macro-1">The recipe macro</a></li><li><a class="toctext" href="#Auxiliary-functions-1">Auxiliary functions</a></li><li><a class="toctext" href="#Customizing-output,-display-and-layout-1">Customizing output, display and layout</a></li><li><a class="toctext" href="#Defining-custom-widgets-without-depending-on-Interact-1">Defining custom widgets without depending on Interact</a></li><li><a class="toctext" href="#A-simpler-approach:-the-manipulate-macro-1">A simpler approach: the manipulate macro</a></li></ul></li><li><a class="toctext" href="layout.html">Layout</a></li><li><a class="toctext" href="deploying.html">Deploying the web app</a></li><li><a class="toctext" href="tutorial.html">Tutorial</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="custom_widgets.html">Custom widgets</a></li></ul><a class="edit-page" href="https://github.com/JuliaGizmos/Interact.jl/blob/master/docs/src/custom_widgets.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Custom widgets</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Custom-widgets-1" href="#Custom-widgets-1">Custom widgets</a></h1><p>Besides the standard widgets, Interact provides a framework to define custom GUIs. This is currently possible with two approaches, the full featured <a href="custom_widgets.html#Widgets.@widget"><code>@widget</code></a> macro and the simple to use but more basic <a href="custom_widgets.html#InteractBase.@manipulate"><code>@manipulate</code></a> macro.</p><h2><a class="nav-anchor" id="The-Widget-type-1" href="#The-Widget-type-1">The Widget type</a></h2><p>The <code>Widget</code> type can be used to create custom widgets. The types is parametric, with the parameter being the name of the widget and it takes as argument a <code>OrderedDict</code> of children.</p><p>For example:</p><pre><code class="language-julia">d = OrderedDict(:label =&gt; &quot;My label&quot;, :button =&gt; button(&quot;My button&quot;))
w = Interact.Widget{:mywidget}(d)</code></pre><p>Children can be accessed and modified using <code>getindex</code> and <code>setindex!</code> on the <code>Widget</code> object:</p><pre><code class="language-julia">println(w[:label])
w[:label] = &quot;A new label&quot;</code></pre><p>The <a href="custom_widgets.html#Widgets.@output!"><code>@output!</code></a> and <a href="custom_widgets.html#Widgets.@display!"><code>@display!</code></a> macros can be used to set the output of the widget and define how to display it.</p><pre><code class="language-julia">@output! w $(:button) &gt; 5 ? &quot;You pressed me many times&quot; : &quot;You didn&#39;t press me enough&quot;
@display! w dom&quot;div&quot;($(_.output), style = Dict(&quot;color&quot; =&gt; &quot;red&quot;))</code></pre><p>Finally the <a href="custom_widgets.html#Widgets.@layout!"><code>@layout!</code></a> macro allows us to set the layout of the widget:</p><pre><code class="language-julia">@layout! w hbox(vbox(:label, :button), _.display)</code></pre><h2><a class="nav-anchor" id="The-recipe-macro-1" href="#The-recipe-macro-1">The recipe macro</a></h2><p>To simplify adding children to a custom widget (as well as to register it as a &quot;widget recipe&quot;), a <code>@widget</code> macro is provided.</p><p>See <a href="tutorial.html#Creating-custom-widgets-1">Creating custom widgets</a> for examples.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@widget" href="#Widgets.@widget"><code>Widgets.@widget</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@widget(wdgname, func_call)</code></p><p>Special macro to create &quot;recipes&quot; for custom widgets. The <code>@widget</code> macro takes to argument, a variable name <code>wdgname</code> and a function call <code>func_call</code>. The function call is changed by the macro in several ways:</p><ul><li><p>an extra line is added at the beginning to initiliaze a variable called <code>wdgname::Widget</code> that can be used to refer to the widget in the function body</p></li><li><p>all lines of the type <code>sym::Symbol = expr</code> are replaced with <code>wdgname[sym] = @map(wdgname, expr)</code>, see <a href="custom_widgets.html#Widgets.@map"><code>Widgets.@map</code></a> for more details</p></li><li><p>an extra line is added at the end to return <code>wdgname</code></p></li></ul><p>The macro then registers the function <code>func_call</code> and exports it. It also overloads the <code>widget</code> function with the following signature:</p><p><code>Widgets.widget(::Val{Symbol(func_name)}, args...; kwargs..) = func_name(args...; kwargs...)</code></p></div><a class="source-link" target="_blank" href="https://github.com/piever/Widgets.jl/blob/201c249a037c1077e4262fcd8c387047100d2e02/src/widget.jl#L72-L85">source</a></section><h2><a class="nav-anchor" id="Auxiliary-functions-1" href="#Auxiliary-functions-1">Auxiliary functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@map" href="#Widgets.@map"><code>Widgets.@map</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@map(d, x)</code></p><p>Apply the expression <code>x</code> to the widget <code>d</code>, replacing e.g. symbol <code>:s</code> with the corresponding <code>Observable</code> <code>observe(d[:s])</code>. To use the value of some of <code>d</code>&#39;s components, use <code>:s[]</code>. Use <code>$(:s)</code> if you want the output to update automatically as soon as the value of <code>observe(d[:s])</code> changes. In this context, <code>_</code> refers to the whole widget. To use actual symbols, escape them with <code>^</code>, as in <code>^(:a)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataStructures, InteractBase, Observables

julia&gt; t = Widgets.Widget{:test}(OrderedDict(:a =&gt; Observable(2), :b =&gt; slider(1:100), :c =&gt; button()));</code></pre><p>This updates as soon as <code>observe(t[:a])</code> or <code>observe(t[:b])</code> change:</p><pre><code class="language-julia-repl">julia&gt; Widgets.@map t $(:a) + $(:b)
Observables.Observable{Int64}(&quot;ob_31&quot;, 52, Any[])</code></pre><p>whereas this only updates when button <code>:c</code> is pressed:</p><pre><code class="language-julia-repl">julia&gt; Widgets.@map t ($(:c); :a[] + :b[])
Observables.Observable{Int64}(&quot;ob_33&quot;, 52, Any[])</code></pre><p><code>@map(x)</code></p><p>Curried version of <code>@map(d, x)</code>: anonymous function mapping <code>d</code> to <code>@map(d, x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/piever/Widgets.jl/blob/201c249a037c1077e4262fcd8c387047100d2e02/src/map.jl#L14-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@map!" href="#Widgets.@map!"><code>Widgets.@map!</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@map!(d, target, x)</code></p><p>In the expression <code>x</code> to the widget <code>d</code>, replace e.g. symbol <code>:s</code> with the corresponding <code>Observable</code> <code>observe(d[:s])</code>. To use the value of some of <code>d</code>&#39;s components, use <code>:s[]</code>. As soon as one of the symbols wrapped in a <code>$</code> changes value, the observable target gets updated with the value of that expression. If no symbol is wrapped in a <code>$</code>, nothing happens. In this context, <code>_</code> refers to the whole widget. To use actual symbols, escape them with <code>^</code>, as in <code>^(:a)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataStructures, InteractBase, Observables

julia&gt; t = Widgets.Widget{:test}(OrderedDict(:a =&gt; Observable(2), :b =&gt; slider(1:100), :c =&gt; button()));</code></pre><p>This updates <code>t[:a]</code> as soon as the user moves the slider:</p><pre><code class="language-julia-repl">julia&gt; Widgets.@map! t :a $(:b);</code></pre><p><code>@map!(target, x)</code></p><p>Curried version of <code>@map!(d, target, x)</code>: anonymous function mapping <code>d</code> to <code>@map(d, target, x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/piever/Widgets.jl/blob/201c249a037c1077e4262fcd8c387047100d2e02/src/map.jl#L64-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@on" href="#Widgets.@on"><code>Widgets.@on</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@on(d, x)</code></p><p>In the expression <code>x</code> to the widget <code>d</code>, replace e.g. symbol <code>:s</code> with the corresponding <code>Observable</code> <code>observe(d[:s])</code>. To use the value of some of <code>d</code>&#39;s components, use <code>:s[]</code>. As soon as one of the symbols wrapped in a <code>$</code> changes value, the expression <code>x</code> gets executed with the updated value. If no symbol is wrapped in a <code>$</code>, nothing happens. In this context, <code>_</code> refers to the whole widget. To use actual symbols, escape them with <code>^</code>, as in <code>^(:a)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataStructures, InteractBase, Observables

julia&gt; t = Widgets.Widget{:test}(OrderedDict(:a =&gt; Observable(2), :b =&gt; slider(1:100), :c =&gt; button()));</code></pre><p>This prints the value of the slider as soon as the user moves it:</p><pre><code class="language-julia-repl">julia&gt; Widgets.@on t println($(:b));</code></pre><p><code>@on(x)</code></p><p>Curried version of <code>@on(d, x)</code>: anonymous function mapping <code>d</code> to <code>@on(d, x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/piever/Widgets.jl/blob/201c249a037c1077e4262fcd8c387047100d2e02/src/on.jl#L13-L38">source</a></section><h2><a class="nav-anchor" id="Customizing-output,-display-and-layout-1" href="#Customizing-output,-display-and-layout-1">Customizing output, display and layout</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@output!" href="#Widgets.@output!"><code>Widgets.@output!</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@output!(d, x)</code></p><p>Computes <code>Widgets.@map(d, x)</code> and sets <code>d.output</code> to be the result (see <a href="custom_widgets.html#Widgets.@map"><code>Widgets.@map</code></a> for more details). <code>d.display</code> is also set by default to match <code>d.output</code>. To have a custom display use <code>@display!(d, expr)</code> _after_ <code>@output!(d, x)</code></p></div><a class="source-link" target="_blank" href="https://github.com/piever/Widgets.jl/blob/201c249a037c1077e4262fcd8c387047100d2e02/src/output.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@display!" href="#Widgets.@display!"><code>Widgets.@display!</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@display!(d, x)</code></p><p>Computes <code>Widgets.@map(d, x)</code> and sets <code>d.display</code> to be the result (see <a href="custom_widgets.html#Widgets.@map"><code>Widgets.@map</code></a> for more details).</p></div><a class="source-link" target="_blank" href="https://github.com/piever/Widgets.jl/blob/201c249a037c1077e4262fcd8c387047100d2e02/src/output.jl#L16-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@layout" href="#Widgets.@layout"><code>Widgets.@layout</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@layout(d, x)</code></p><p>Apply the expression <code>x</code> to the widget <code>d</code>, replacing e.g. symbol <code>:s</code> with the corresponding subwidget <code>d[:s]</code> To create a layout that updates automatically as some <code>Widget</code> or <code>Observable</code> updates, use <code>$(:s)</code>. In this context, <code>_</code> refers to the whole widget. To use actual symbols, escape them with <code>^</code>, as in <code>^(:a)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataStructures, InteractBase, CSSUtil

julia&gt; t = Widgets.Widget{:test}(OrderedDict(:vertical =&gt; Observable(true), :b =&gt; slider(1:100), :c =&gt; button()));

julia&gt; Widgets.@layout t vertical ? vbox(:b, CSSUtil.vskip(1em), :c) : hbox(:b, CSSUtil.hskip(1em), :c);</code></pre><p><code>@layout(x)</code></p><p>Curried version of <code>@layout(d, x)</code>: anonymous function mapping <code>d</code> to <code>@layout(d, x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/piever/Widgets.jl/blob/201c249a037c1077e4262fcd8c387047100d2e02/src/layout.jl#L1-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@layout!" href="#Widgets.@layout!"><code>Widgets.@layout!</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@layout!(d, x)</code></p><p>Set <code>d.layout</code> to match the result of <code>Widgets.@layout(x)</code>. See <a href="custom_widgets.html#Widgets.@layout"><code>Widgets.@layout</code></a> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataStructures, InteractBase, CSSUtil

julia&gt; t = Widgets.Widget{:test}(OrderedDict(:b =&gt; slider(1:100), :c =&gt; button()));

julia&gt; @layout! t hbox(:b, CSSUtil.hskip(1em), :c);</code></pre></div><a class="source-link" target="_blank" href="https://github.com/piever/Widgets.jl/blob/201c249a037c1077e4262fcd8c387047100d2e02/src/layout.jl#L43-L57">source</a></section><h2><a class="nav-anchor" id="Defining-custom-widgets-without-depending-on-Interact-1" href="#Defining-custom-widgets-without-depending-on-Interact-1">Defining custom widgets without depending on Interact</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@nodeps" href="#Widgets.@nodeps"><code>Widgets.@nodeps</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@nodeps(expr)</code></p><p>Macro to remove need to depend on package X that defines a recipe to use it in one&#39;s own recipe. For example, InteractBase defines <code>dropwdown</code> recipe. To use <code>dropdown</code> in a recipe in a package, without depending on InteractBase, wrap the <code>dropdown</code> call in the <code>@nodeps</code> macro:</p><pre><code class="language-julia">@widget wdg function myrecipe(i)
    :label = &quot;My recipe&quot;
    :dropdown = Widgets.@nodeps dropdown(i)
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/piever/Widgets.jl/blob/201c249a037c1077e4262fcd8c387047100d2e02/src/utils.jl#L72-L85">source</a></section><h2><a class="nav-anchor" id="A-simpler-approach:-the-manipulate-macro-1" href="#A-simpler-approach:-the-manipulate-macro-1">A simpler approach: the manipulate macro</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InteractBase.@manipulate" href="#InteractBase.@manipulate"><code>InteractBase.@manipulate</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@manipulate expr</code></p><p>The @manipulate macro lets you play with any expression using widgets. <code>expr</code> needs to be a <code>for</code> loop. The <code>for</code> loop variable are converted to widgets using the <a href="widgets.html#Widgets.widget"><code>widget</code></a> function (ranges become <code>slider</code>, lists of options become <code>togglebuttons</code>, etc...). The <code>for</code> loop body is displayed beneath the widgets and automatically updated as soon as the widgets change value.</p><p>Use <code>throttle = df</code> to only update the output after a small time interval <code>dt</code> (useful if the update is costly as it prevents multiple updates when moving for example a slider).</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Colors

@manipulate for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1
    HTML(string(&quot;&lt;div style=&#39;color:#&quot;, hex(RGB(r,g,b)), &quot;&#39;&gt;Color me&lt;/div&gt;&quot;))
end

@manipulate throttle = 0.1 for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1
    HTML(string(&quot;&lt;div style=&#39;color:#&quot;, hex(RGB(r,g,b)), &quot;&#39;&gt;Color me&lt;/div&gt;&quot;))
end</code></pre><p><a href="custom_widgets.html#Widgets.@layout!"><code>@layout!</code></a> can be used to adjust the layout of a manipulate block:</p><pre><code class="language-julia">using Widgets, CSSUtil, WebIO

ui = @manipulate throttle = 0.1 for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1
    HTML(string(&quot;&lt;div style=&#39;color:#&quot;, hex(RGB(r,g,b)), &quot;&#39;&gt;Color me&lt;/div&gt;&quot;))
end
@layout! ui dom&quot;div&quot;(_.display, vskip(2em), :r, :g, :b)
ui</code></pre></div><a class="source-link" target="_blank" href="https://github.com/piever/InteractBase.jl/blob/c807b70bd0b4bc9bef6d421614570c67e5b18679/src/manipulate.jl#L31-L66">source</a></section><footer><hr/><a class="previous" href="widgets.html"><span class="direction">Previous</span><span class="title">Widgets</span></a><a class="next" href="layout.html"><span class="direction">Next</span><span class="title">Layout</span></a></footer></article></body></html>
