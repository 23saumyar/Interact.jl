<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Custom widgets · Interact</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Interact</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="observables.html">Observables</a></li><li><a class="toctext" href="widgets.html">Widgets</a></li><li class="current"><a class="toctext" href="custom_widgets.html">Custom widgets</a><ul class="internal"><li><a class="toctext" href="#The-Widget-type-1">The Widget type</a></li><li><a class="toctext" href="#Defining-custom-widgets-without-depending-on-Interact-1">Defining custom widgets without depending on Interact</a></li><li><a class="toctext" href="#A-simpler-approach:-the-manipulate-macro-1">A simpler approach: the manipulate macro</a></li></ul></li><li><a class="toctext" href="layout.html">Layout</a></li><li><a class="toctext" href="deploying.html">Deploying the web app</a></li><li><a class="toctext" href="tutorial.html">Tutorial</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="custom_widgets.html">Custom widgets</a></li></ul><a class="edit-page" href="https://github.com/JuliaGizmos/Interact.jl/blob/master/docs/src/custom_widgets.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Custom widgets</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Custom-widgets-1" href="#Custom-widgets-1">Custom widgets</a></h1><p>Besides the standard widgets, Interact provides a framework to define custom GUIs. This is currently possible with two approaches, the full featured <code>Widget</code> type and the simple to use but more basic <a href="custom_widgets.html#InteractBase.@manipulate"><code>@manipulate</code></a> macro.</p><h2><a class="nav-anchor" id="The-Widget-type-1" href="#The-Widget-type-1">The Widget type</a></h2><p>The <code>Widget</code> type can be used to create custom widgets. The types is parametric, with the parameter being the name of the widget and it takes as argument a <code>OrderedDict</code> of children.</p><p>For example:</p><pre><code class="language-julia">d = OrderedDict(:label =&gt; &quot;My label&quot;, :button =&gt; button(&quot;My button&quot;))
w = Widget{:mywidget}(d)</code></pre><p>Children can be accessed and modified using <code>getindex</code> and <code>setindex!</code> on the <code>Widget</code> object:</p><pre><code class="language-julia">println(w[:label])
w[:label] = &quot;A new label&quot;</code></pre><p>Optionally, the <code>Widget</code> can have some output, which should be an <code>Observable</code>:</p><pre><code class="language-julia">d = OrderedDict(:label =&gt; &quot;My label&quot;, :button =&gt; button(&quot;My button&quot;))
output = map(t -&gt; t &gt; 5 ? &quot;You pressed me many times&quot; : &quot;You didn&#39;t press me enough&quot;, d[:button])
w = Interact.Widget{:mywidget}(d, output = output)</code></pre><p>Finally the <a href="custom_widgets.html#Widgets.@layout!"><code>@layout!</code></a> macro allows us to set the layout of the widget:</p><pre><code class="language-julia">@layout! w hbox(vbox(:label, :button), observe(_)) # observe(_) refers to the output of the widget</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@layout!" href="#Widgets.@layout!"><code>Widgets.@layout!</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@layout!(d, x)</code></p><p>Set <code>d.layout</code> to match the result of <code>Widgets.@layout(x)</code>. See <a href="custom_widgets.html#Widgets.@layout"><code>Widgets.@layout</code></a> for more information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataStructures, InteractBase, CSSUtil

julia&gt; t = Widgets.Widget{:test}(OrderedDict(:b =&gt; slider(1:100), :c =&gt; button()));

julia&gt; @layout! t hbox(:b, CSSUtil.hskip(1em), :c);</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@layout" href="#Widgets.@layout"><code>Widgets.@layout</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@layout(d, x)</code></p><p>Apply the expression <code>x</code> to the widget <code>d</code>, replacing e.g. symbol <code>:s</code> with the corresponding subwidget <code>d[:s]</code> In this context, <code>_</code> refers to the whole widget. To use actual symbols, escape them with <code>^</code>, as in <code>^(:a)</code>. <code>@layout</code> can be combined with <code>@map</code> to have the layout update interactively as function of some widget.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DataStructures, InteractBase, CSSUtil

julia&gt; cpt = OrderedDict(:vertical =&gt; Observable(true), :b =&gt; slider(1:100), :c =&gt; button());

julia&gt; t = Widgets.Widget{:test}(cpt, output = observe(cpt[:b]));

julia&gt; Widgets.@layout t vbox(:b, CSSUtil.vskip(1em), :c);

julia&gt; Widgets.@layout t Widgets.@map &amp;(:vertical) ? vbox(:b, CSSUtil.vskip(1em), :c) : hbox(:b, CSSUtil.hskip(1em), :c);</code></pre><p>Use <a href="custom_widgets.html#Widgets.@layout!"><code>Widgets.@layout!</code></a> to set the widget layout in place:</p><pre><code class="language-julia-repl">julia&gt; Widgets.@layout! t Widgets.@map &amp;(:vertical) ? vbox(:b, CSSUtil.vskip(1em), :c) : hbox(:b, CSSUtil.hskip(1em), :c);</code></pre><p><code>@layout(x)</code></p><p>Curried version of <code>@layout(d, x)</code>: anonymous function mapping <code>d</code> to <code>@layout(d, x)</code>.</p></div></div></section><h2><a class="nav-anchor" id="Defining-custom-widgets-without-depending-on-Interact-1" href="#Defining-custom-widgets-without-depending-on-Interact-1">Defining custom widgets without depending on Interact</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Widgets.@nodeps" href="#Widgets.@nodeps"><code>Widgets.@nodeps</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@nodeps(expr)</code></p><p>Macro to remove need to depend on package X that defines a recipe to use it in one&#39;s own recipe. For example, InteractBase defines <code>dropwdown</code> recipe. To use <code>dropdown</code> in a recipe in a package, without depending on InteractBase, wrap the <code>dropdown</code> call in the <code>@nodeps</code> macro:</p><pre><code class="language-julia">@widget wdg function myrecipe(i)
    :label = &quot;My recipe&quot;
    :dropdown = Widgets.@nodeps dropdown(i)
end</code></pre></div></div></section><h2><a class="nav-anchor" id="A-simpler-approach:-the-manipulate-macro-1" href="#A-simpler-approach:-the-manipulate-macro-1">A simpler approach: the manipulate macro</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InteractBase.@manipulate" href="#InteractBase.@manipulate"><code>InteractBase.@manipulate</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><code>@manipulate expr</code></p><p>The @manipulate macro lets you play with any expression using widgets. <code>expr</code> needs to be a <code>for</code> loop. The <code>for</code> loop variable are converted to widgets using the <a href="widgets.html#Widgets.widget"><code>widget</code></a> function (ranges become <code>slider</code>, lists of options become <code>togglebuttons</code>, etc...). The <code>for</code> loop body is displayed beneath the widgets and automatically updated as soon as the widgets change value.</p><p>Use <code>throttle = df</code> to only update the output after a small time interval <code>dt</code> (useful if the update is costly as it prevents multiple updates when moving for example a slider).</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Colors

@manipulate for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1
    HTML(string(&quot;&lt;div style=&#39;color:#&quot;, hex(RGB(r,g,b)), &quot;&#39;&gt;Color me&lt;/div&gt;&quot;))
end

@manipulate throttle = 0.1 for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1
    HTML(string(&quot;&lt;div style=&#39;color:#&quot;, hex(RGB(r,g,b)), &quot;&#39;&gt;Color me&lt;/div&gt;&quot;))
end</code></pre><p><a href="custom_widgets.html#Widgets.@layout!"><code>@layout!</code></a> can be used to adjust the layout of a manipulate block:</p><pre><code class="language-julia">using Interact

ui = @manipulate throttle = 0.1 for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1
    HTML(string(&quot;&lt;div style=&#39;color:#&quot;, hex(RGB(r,g,b)), &quot;&#39;&gt;Color me&lt;/div&gt;&quot;))
end
@layout! ui dom&quot;div&quot;(observe(_), vskip(2em), :r, :g, :b)
ui</code></pre></div></div></section><footer><hr/><a class="previous" href="widgets.html"><span class="direction">Previous</span><span class="title">Widgets</span></a><a class="next" href="layout.html"><span class="direction">Next</span><span class="title">Layout</span></a></footer></article></body></html>
