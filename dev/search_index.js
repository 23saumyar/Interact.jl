var documenterSearchIndex = {"docs":
[{"location":"#Interact-1","page":"Introduction","title":"Interact","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Interact allows to create small GUIs in Julia based on web technology. These GUIs can be deployed in jupyter notebooks, in the Juno IDE plot pane, in an Electron window or in the browser.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"To understand how to use it go through the Tutorial. The tutorial is also available here as a Jupyter notebook.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"InteractBase, Knockout and WebIO provide the logic that allows the communication between Julia and Javascript and the organization of the widgets.","category":"page"},{"location":"#Overview-1","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Creating an app in Interact requires three ingredients:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Observables: references that can listen to changes in other references\nWidgets: the graphical elements that make up the app\nLayout: tools to assemble together different widgets","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"To get a quick overview of how these tools work together, go to Tutorial.","category":"page"},{"location":"#CSS-framework-1","page":"Introduction","title":"CSS framework","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Interact widgets are by default styled with the Bulma CSS framework (the previously supported UIkit backend is now deprecated). Bulma is a pure CSS framework (no extra Javascript), which leaves Julia fully in control of manipulating the DOM (which in turn means less surface area for bugs).","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"To use unstyled widgets in the middle of the session (or to style them again) simply do:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"settheme!(:nativehtml)\nsettheme!(:bulma)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"respectively.","category":"page"},{"location":"#Deployment-1","page":"Introduction","title":"Deployment","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"InteractBase works with the following frontends:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Juno - The hottest Julia IDE\nIJulia - Jupyter notebooks (and Jupyter Lab) for Julia\nBlink - An Electron wrapper you can use to make Desktop apps\nMux - A web server framework","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"See Deploying the web app for instructions.","category":"page"},{"location":"observables/#Observables-1","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"observables/#","page":"Observables","title":"Observables","text":"Observables are like Refs but you can listen to changes.","category":"page"},{"location":"observables/#","page":"Observables","title":"Observables","text":"using Interact\n\nobservable = Observable(0)\n\nh = on(observable) do val\n    println(\"Got an update: \", val)\nend\n\nobservable[] = 42","category":"page"},{"location":"observables/#","page":"Observables","title":"Observables","text":"To get the value of an observable index it with no arguments","category":"page"},{"location":"observables/#","page":"Observables","title":"Observables","text":"observable[]","category":"page"},{"location":"observables/#","page":"Observables","title":"Observables","text":"To remove a handler use off with the return value of on:","category":"page"},{"location":"observables/#","page":"Observables","title":"Observables","text":"off(observable, h)","category":"page"},{"location":"observables/#How-is-it-different-from-Reactive.jl?-1","page":"Observables","title":"How is it different from Reactive.jl?","text":"","category":"section"},{"location":"observables/#","page":"Observables","title":"Observables","text":"The main difference is Signals are manipulated mostly by converting one signal to another. For example, with signals, you can construct a changing UI by creating a Signal of UI objects and rendering them as the signal changes. On the other hand, you can use an Observable both as an input and an output. You can arbitrarily attach outputs to inputs allowing structuring code in a signals-and-slots kind of pattern.","category":"page"},{"location":"observables/#","page":"Observables","title":"Observables","text":"Another difference is Observables are synchronous, Signals are asynchronous. Observables may be better suited for an imperative style of programming.","category":"page"},{"location":"observables/#API-1","page":"Observables","title":"API","text":"","category":"section"},{"location":"observables/#Type-1","page":"Observables","title":"Type","text":"","category":"section"},{"location":"observables/#","page":"Observables","title":"Observables","text":"Observable{T}","category":"page"},{"location":"observables/#Observables.Observable","page":"Observables","title":"Observables.Observable","text":"Like a Ref but updates can be watched by adding a handler using on.\n\n\n\n\n\n","category":"type"},{"location":"observables/#Functions-1","page":"Observables","title":"Functions","text":"","category":"section"},{"location":"observables/#","page":"Observables","title":"Observables","text":"on(f, o::Observable)\noff(o::Observable, f)\nBase.setindex!(o::Observable, val)\nBase.getindex(o::Observable)\nonany(f, os...)\nBase.map!(f, o::Observable, os...)\nconnect!(o1::Observable, o2::Observable)\nBase.map(f, o::Observable, os...; init)\nthrottle(dt, o::Observable)","category":"page"},{"location":"observables/#Observables.on-Tuple{Any,Observable}","page":"Observables","title":"Observables.on","text":"on(f, o::AbstractObservable)\n\nAdds function f as listener to o. Whenever o's value is set via o[] = val f is called with val.\n\n\n\n\n\n","category":"method"},{"location":"observables/#Observables.off-Tuple{Observable,Any}","page":"Observables","title":"Observables.off","text":"off(o::AbstractObservable, f)\n\nRemoves f from listeners of o.\n\n\n\n\n\n","category":"method"},{"location":"observables/#Base.setindex!-Tuple{Observable,Any}","page":"Observables","title":"Base.setindex!","text":"o[] = val\n\nUpdates the value of an Observable to val and call its listeners.\n\n\n\n\n\n","category":"method"},{"location":"observables/#Base.getindex-Tuple{Observable}","page":"Observables","title":"Base.getindex","text":"o[]\n\nReturns the current value of o.\n\n\n\n\n\n","category":"method"},{"location":"observables/#Observables.onany-Tuple{Any,Vararg{Any,N} where N}","page":"Observables","title":"Observables.onany","text":"onany(f, args...)\n\nCalls f on updates to any oservable refs in args. args may contain any number of Observable ojects. f will be passed the values contained in the refs as the respective argument. All other ojects in args are passed as-is.\n\n\n\n\n\n","category":"method"},{"location":"observables/#Base.map!-Tuple{Any,Observable,Vararg{Any,N} where N}","page":"Observables","title":"Base.map!","text":"map!(f, o::Observable, args...)\n\nUpdates o with the result of calling f with values extracted from args. args may contain any number of Observable ojects. f will be passed the values contained in the refs as the respective argument. All other ojects in args are passed as-is.\n\n\n\n\n\n","category":"method"},{"location":"observables/#Observables.connect!-Tuple{Observable,Observable}","page":"Observables","title":"Observables.connect!","text":"connect!(o1::Observable, o2::Observable)\n\nForward all updates to o1 to o2\n\n\n\n\n\n","category":"method"},{"location":"observables/#Base.map-Tuple{Any,Observable,Vararg{Any,N} where N}","page":"Observables","title":"Base.map","text":"map(f, o::Observable, args...)\n\nCreates a new oservable ref which contains the result of f applied to values extracted from args. The second argument o must be an oservable ref for dispatch reasons. args may contain any number of Observable ojects. f will be passed the values contained in the refs as the respective argument. All other ojects in args are passed as-is.\n\n\n\n\n\n","category":"method"},{"location":"observables/#Observables.throttle-Tuple{Any,Observable}","page":"Observables","title":"Observables.throttle","text":"throttle(dt, input::AbstractObservable)\n\nThrottle a signal to update at most once every dt seconds. The throttled signal holds the last update of the input signal during each dt second time window.\n\n\n\n\n\n","category":"method"},{"location":"observables/#Macros-1","page":"Observables","title":"Macros","text":"","category":"section"},{"location":"observables/#","page":"Observables","title":"Observables","text":"Interact.@map\nInteract.@map!\nInteract.@on","category":"page"},{"location":"observables/#Observables.@map","page":"Observables","title":"Observables.@map","text":"@map(expr)\n\nWrap AbstractObservables in & to compute expression expr using their value. The expression will be computed when @map is called and  every time the AbstractObservables are updated.\n\nExamples\n\njulia> a = Observable(2);\n\njulia> b = Observable(3);\n\njulia> c = Observables.@map &a + &b;\n\njulia> c[]\n5\n\njulia> a[] = 100\n100\n\njulia> c[]\n103\n\n\n\n\n\n","category":"macro"},{"location":"observables/#Observables.@map!","page":"Observables","title":"Observables.@map!","text":"@map!(d, expr)\n\nWrap AbstractObservables in & to compute expression expr using their value: the expression will be computed every time the AbstractObservables are updated and d will be set to match that value.\n\nExamples\n\njulia> a = Observable(2);\n\njulia> b = Observable(3);\n\njulia> c = Observable(10);\n\njulia> Observables.@map! c &a + &b;\n\njulia> c[]\n10\n\njulia> a[] = 100\n100\n\njulia> c[]\n103\n\n\n\n\n\n","category":"macro"},{"location":"observables/#Observables.@on","page":"Observables","title":"Observables.@on","text":"@on(expr)\n\nWrap AbstractObservables in & to execute expression expr using their value. The expression will be computed every time the AbstractObservables are updated.\n\nExamples\n\njulia> a = Observable(2);\n\njulia> b = Observable(3);\n\njulia> Observables.@on println(\"The sum of a+b is $(&a + &b)\");\n\njulia> a[] = 100;\nThe sum of a+b is 103\n\n\n\n\n\n","category":"macro"},{"location":"widgets/#Widgets-1","page":"Widgets","title":"Widgets","text":"","category":"section"},{"location":"widgets/#What-is-a-widget?-1","page":"Widgets","title":"What is a widget?","text":"","category":"section"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"A widget is simply some graphical component that we can generate from Julia and that has an output. The output of a widget is a Observable and can be accessed with observe.","category":"page"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"A Widget itself behaves pretty much like a Observable and the techniques discussed in Observables apply. For example:","category":"page"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"using Interact\ns = slider(1:100);\ns[]\nInteract.@on print(string(\"The value is \", &s))\ns[] = 12;","category":"page"},{"location":"widgets/#Text-input-1","page":"Widgets","title":"Text input","text":"","category":"section"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"These are widgets to select text input that's typed in by the user. For numbers use spinbox and for strings use textbox. String entries (textbox and autocomplete) are initialized as \"\", whereas spinbox defaults to nothing, which corresponds to the empty entry.","category":"page"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"spinbox\ntextbox\ntextarea\nautocomplete","category":"page"},{"location":"widgets/#Widgets.spinbox","page":"Widgets","title":"Widgets.spinbox","text":"spinbox([range,] label=\"\"; value=nothing)\n\nCreate a widget to select numbers with placeholder label. An optional range first argument specifies maximum and minimum value accepted as well as the step.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.textbox","page":"Widgets","title":"Widgets.textbox","text":"textbox(hint=\"\"; value=\"\")\n\nCreate a text input area with an optional placeholder hint e.g. textbox(\"enter number:\"). Use typ=... to specify the type of text. For example typ=\"email\" or typ=password. Use multiline=true to display a textarea spanning several lines.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.textarea","page":"Widgets","title":"Widgets.textarea","text":"textarea(hint=\"\"; value=\"\")\n\nCreate a textarea with an optional placeholder hint e.g. textarea(\"enter number:\"). Use rows=... to specify how many rows to display\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.autocomplete","page":"Widgets","title":"Widgets.autocomplete","text":"autocomplete(options, label=\"\"; value=\"\")\n\nCreate a textbox input with autocomplete options specified by options, with value as initial value and label as label.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Type-input-1","page":"Widgets","title":"Type input","text":"","category":"section"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"These are widgets to select a specific, non-text, type of input. So far, Date, Time, Color and Bool are supported. Types that allow a empty field (Date and Time) are initialized as nothing by default, whereas Color and Bool are initialized with the default HTML value (colorant\"black\" and false respectively).","category":"page"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"datepicker\ntimepicker\ncolorpicker\ncheckbox\ntoggle","category":"page"},{"location":"widgets/#Widgets.datepicker","page":"Widgets","title":"Widgets.datepicker","text":"datepicker(value::Union{Dates.Date, Observable, Nothing}=nothing)\n\nCreate a widget to select dates.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.timepicker","page":"Widgets","title":"Widgets.timepicker","text":"timepicker(value::Union{Dates.Time, Observable, Nothing}=nothing)\n\nCreate a widget to select times.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.colorpicker","page":"Widgets","title":"Widgets.colorpicker","text":"colorpicker(value::Union{Color, Observable}=colorant\"#000000\")\n\nCreate a widget to select colors.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.checkbox","page":"Widgets","title":"Widgets.checkbox","text":"checkbox(value::Union{Bool, AbstractObservable}=false; label)\n\nA checkbox. e.g. checkbox(label=\"be my friend?\")\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.toggle","page":"Widgets","title":"Widgets.toggle","text":"toggle(value::Union{Bool, AbstractObservable}=false; label)\n\nA toggle switch. e.g. toggle(label=\"be my friend?\")\n\n\n\n\n\n","category":"function"},{"location":"widgets/#File-input-1","page":"Widgets","title":"File input","text":"","category":"section"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"filepicker\nopendialog\nsavedialog","category":"page"},{"location":"widgets/#Widgets.filepicker","page":"Widgets","title":"Widgets.filepicker","text":"filepicker(label=\"Choose a file...\"; multiple=false, accept=\"*\")\n\nCreate a widget to select files. If multiple=true the observable will hold an array containing the paths of all selected files. Use accept to only accept some formats, e.g. accept=\".csv\"\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.opendialog","page":"Widgets","title":"Widgets.opendialog","text":"opendialog(; value = String[], label = \"Open\", icon = \"far fa-folder-open\", options...)\n\nCreates an Electron openDialog. value is the list of selected files or folders. options (given as keyword arguments) correspond to options of the Electron dialog. This widget will not work in the browser but only in an Electron window.\n\nExamples\n\njulia> ui = InteractBase.opendialog(; properties = [\"showHiddenFiles\", \"multiSelections\"], filters = [(; name = \"Text\", extensions = [\"txt\", \"md\"])]);\n\njulia> ui[]\n0-element Array{String,1}\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.savedialog","page":"Widgets","title":"Widgets.savedialog","text":"savedialog(; value = String[], label = \"Open\", icon = \"far fa-folder-open\", options...)\n\nCreate an Electron saveDialog. value is the list of selected files or folders. options (given as keyword arguments) correspond to options of the Electron dialog. This widget will not work in the browser but only in an Electron window.\n\nExamples\n\njulia> ui = InteractBase.savedialog(; properties = [\"showHiddenFiles\"], filters = [(; name = \"Text\", extensions = [\"txt\", \"md\"])]);\n\njulia> ui[]\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Range-input-1","page":"Widgets","title":"Range input","text":"","category":"section"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"slider\nrangeslider\nrangepicker","category":"page"},{"location":"widgets/#Widgets.slider","page":"Widgets","title":"Widgets.slider","text":"function slider(vals::AbstractArray;\n                value=medianelement(vals),\n                label=nothing, readout=true, kwargs...)\n\nCreates a slider widget which can take on the values in vals, and updates observable value when the slider is changed.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.rangeslider","page":"Widgets","title":"Widgets.rangeslider","text":"function rangeslider(vals::AbstractArray;\n                value=medianelement(vals),\n                label=nothing, readout=true, kwargs...)\n\nCreates a slider widget which can take on the values in vals and accepts several \"handles\". Pass a vector to value with two values if you want to select a range.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.rangepicker","page":"Widgets","title":"Widgets.rangepicker","text":"function rangepicker(vals::AbstractArray;\n                value=[extrema(vals)...],\n                label=nothing, readout=true, kwargs...)\n\nA multihandle slider with a set of spinboxes, one per handle.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Callback-input-1","page":"Widgets","title":"Callback input","text":"","category":"section"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"button","category":"page"},{"location":"widgets/#Widgets.button","page":"Widgets","title":"Widgets.button","text":"button(content... = \"Press me!\"; value=0)\n\nA button. content goes inside the button. Note the button content supports a special clicks variable, that gets incremented by 1 with each click e.g.: button(\"clicked {{clicks}} times\"). The clicks variable is initialized at value=0. Given a button b, b[\"is-loading\"] defines whether the button is in a loading state (spinning wheel). Use b[\"is-loading\"][]=true or b[\"is-loading\"][]=false respectively to display or take away the spinner.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#HTML5-input-1","page":"Widgets","title":"HTML5 input","text":"","category":"section"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"All of the inputs above are implemented wrapping the input tag of HTML5 which can be accessed more directly as follows:","category":"page"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"InteractBase.input","category":"page"},{"location":"widgets/#Widgets.input","page":"Widgets","title":"Widgets.input","text":"input(o; typ=\"text\")\n\nCreate an HTML5 input element of type type (e.g. \"text\", \"color\", \"number\", \"date\") with o as initial value.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Option-input-1","page":"Widgets","title":"Option input","text":"","category":"section"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"dropdown\nradiobuttons\ncheckboxes\ntoggles\ntogglebuttons\ntabs","category":"page"},{"location":"widgets/#Widgets.dropdown","page":"Widgets","title":"Widgets.dropdown","text":"dropdown(options::AbstractDict;\n         value = first(values(options)),\n         label = nothing,\n         multiple = false)\n\nA dropdown menu whose item labels are the keys of options. If multiple=true the observable will hold an array containing the values of all selected items e.g. dropdown(OrderedDict(\"good\"=>1, \"better\"=>2, \"amazing\"=>9001))\n\ndropdown(values::AbstractArray; kwargs...)\n\ndropdown with labels string.(values) see dropdown(options::AbstractDict; ...) for more details\n\n\n\n\n\ndropdown(options::AbstractObservable;\n         value = first(values(options[])),\n         label = nothing,\n         multiple = false)\n\nA dropdown menu whose options are a given Observable. Set the Observable to some other value to update the options in real time.\n\nExamples\n\noptions = Observable([\"a\", \"b\", \"c\"])\nwdg = dropdown(options)\noptions[] = [\"c\", \"d\", \"e\"]\n\nNote that the options can be modified from the widget directly:\n\nwdg[:options][] = [\"c\", \"d\", \"e\"]\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.radiobuttons","page":"Widgets","title":"Widgets.radiobuttons","text":"radiobuttons(options::AbstractDict;\n             value::Union{T, Observable} = first(values(options)))\n\ne.g. radiobuttons(OrderedDict(\"good\"=>1, \"better\"=>2, \"amazing\"=>9001))\n\nradiobuttons(values::AbstractArray; kwargs...)\n\nradiobuttons with labels string.(values) see radiobuttons(options::AbstractDict; ...) for more details\n\nradiobuttons(options::AbstractObservable; kwargs...)\n\nRadio buttons whose options are a given Observable. Set the Observable to some other value to update the options in real time.\n\nExamples\n\noptions = Observable([\"a\", \"b\", \"c\"])\nwdg = radiobuttons(options)\noptions[] = [\"c\", \"d\", \"e\"]\n\nNote that the options can be modified from the widget directly:\n\nwdg[:options][] = [\"c\", \"d\", \"e\"]\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.checkboxes","page":"Widgets","title":"Widgets.checkboxes","text":"checkboxes(options::AbstractDict;\n         value = first(values(options)))\n\nA list of checkboxes whose item labels are the keys of options. Tthe observable will hold an array containing the values of all selected items, e.g. checkboxes(OrderedDict(\"good\"=>1, \"better\"=>2, \"amazing\"=>9001))\n\ncheckboxes(values::AbstractArray; kwargs...)\n\ncheckboxes with labels string.(values) see checkboxes(options::AbstractDict; ...) for more details\n\ncheckboxes(options::AbstractObservable; kwargs...)\n\nCheckboxes whose options are a given Observable. Set the Observable to some other value to update the options in real time.\n\nExamples\n\noptions = Observable([\"a\", \"b\", \"c\"])\nwdg = checkboxes(options)\noptions[] = [\"c\", \"d\", \"e\"]\n\nNote that the options can be modified from the widget directly:\n\nwdg[:options][] = [\"c\", \"d\", \"e\"]\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.toggles","page":"Widgets","title":"Widgets.toggles","text":"toggles(options::AbstractDict;\n         value = first(values(options)))\n\nA list of toggle switches whose item labels are the keys of options. Tthe observable will hold an array containing the values of all selected items, e.g. toggles(OrderedDict(\"good\"=>1, \"better\"=>2, \"amazing\"=>9001))\n\ntoggles(values::AbstractArray; kwargs...)\n\ntoggles with labels string.(values) see toggles(options::AbstractDict; ...) for more details\n\ntoggles(options::AbstractObservable; kwargs...)\n\nToggles whose options are a given Observable. Set the Observable to some other value to update the options in real time.\n\nExamples\n\noptions = Observable([\"a\", \"b\", \"c\"])\nwdg = toggles(options)\noptions[] = [\"c\", \"d\", \"e\"]\n\nNote that the options can be modified from the widget directly:\n\nwdg[:options][] = [\"c\", \"d\", \"e\"]\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.togglebuttons","page":"Widgets","title":"Widgets.togglebuttons","text":"togglebuttons(options::AbstractDict; value::Union{T, Observable}, multiple=false)\n\nCreates a set of toggle buttons whose labels are the keys of options. Set multiple=true to allow multiple (or zero) active buttons at the same time.\n\ntogglebuttons(values::AbstractArray; kwargs...)\n\ntogglebuttons with labels string.(values) see togglebuttons(options::AbstractDict; ...) for more details\n\ntogglebuttons(options::AbstractObservable; kwargs...)\n\nTogglebuttons whose options are a given Observable. Set the Observable to some other value to update the options in real time.\n\nExamples\n\noptions = Observable([\"a\", \"b\", \"c\"])\nwdg = togglebuttons(options)\noptions[] = [\"c\", \"d\", \"e\"]\n\nNote that the options can be modified from the widget directly:\n\nwdg[:options][] = [\"c\", \"d\", \"e\"]\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.tabs","page":"Widgets","title":"Widgets.tabs","text":"tabs(options::AbstractDict; value::Union{T, Observable})\n\nCreates a set of tabs whose labels are the keys of options. The label can be a link.\n\ntabs(values::AbstractArray; kwargs...)\n\ntabs with labels values see tabs(options::AbstractDict; ...) for more details\n\ntabs(options::AbstractObservable; kwargs...)\n\nTabs whose options are a given Observable. Set the Observable to some other value to update the options in real time.\n\nExamples\n\noptions = Observable([\"a\", \"b\", \"c\"])\nwdg = tabs(options)\noptions[] = [\"c\", \"d\", \"e\"]\n\nNote that the options can be modified from the widget directly:\n\nwdg[:options][] = [\"c\", \"d\", \"e\"]\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Output-1","page":"Widgets","title":"Output","text":"","category":"section"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"latex\nalert\nhighlight\nInteractBase.notifications\ntogglecontent\ntabulator\nmask","category":"page"},{"location":"widgets/#Widgets.latex","page":"Widgets","title":"Widgets.latex","text":"latex(txt)\n\nRender txt in LaTeX using KaTeX. Backslashes need to be escaped: latex(\"\\\\sum_{i=1}^{\\\\infty} e^i\")\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.alert","page":"Widgets","title":"Widgets.alert","text":"alert(text=\"\")\n\nCreates a Widget{:alert}. To cause it to trigger an alert, do:\n\nwdg = alert(\"Error!\")\nwdg()\n\nCalling wdg with a string will set the alert message to that string before triggering the alert:\n\nwdg = alert(\"Error!\")\nwdg(\"New error message!\")\n\nFor the javascript to work, the widget needs to be part of the UI, even though it is not visible.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.highlight","page":"Widgets","title":"Widgets.highlight","text":"highlight(txt; language = \"julia\")\n\nlanguage syntax highlighting for txt.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.notifications","page":"Widgets","title":"Widgets.notifications","text":"notifications(v=[]; layout = node(:div))\n\nDisplay elements of v inside notification boxes that can be closed with a close button. The elements are laid out according to layout. observe on this widget returns the observable of the list of elements that have not bein deleted.\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.togglecontent","page":"Widgets","title":"Widgets.togglecontent","text":"togglecontent(content, value::Union{Bool, Observable}=false; label)\n\nA toggle switch that, when activated, displays content e.g. togglecontent(checkbox(\"Yes, I am sure\"), false, label=\"Are you sure?\")\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.tabulator","page":"Widgets","title":"Widgets.tabulator","text":"tabulator(options::AbstractDict; index, key)\n\nCreates a set of toggle buttons whose labels are the keys of options. Displays the value of the selected option underneath. Use index::Int to select which should be the index of the initial option, or key::String. The output is the selected index. Use index=0 to not have any selected option.\n\nExamples\n\ntabulator(OrderedDict(\"plot\" => plot(rand(10)), \"scatter\" => scatter(rand(10))), index = 1)\ntabulator(OrderedDict(\"plot\" => plot(rand(10)), \"scatter\" => scatter(rand(10))), key = \"plot\")\n\ntabulator(values::AbstractArray; kwargs...)\n\ntabulator with labels values see tabulator(options::AbstractDict; ...) for more details\n\ntabulator(options::Observable; navbar=tabs, kwargs...)\n\nTabulator whose options are a given Observable. Set the Observable to some other value to update the options in real time. Defaults to navbar=tabs: use navbar=togglebuttons to have buttons instead of tabs.\n\nExamples\n\noptions = Observable([\"a\", \"b\", \"c\"])\nwdg = tabulator(options)\noptions[] = [\"c\", \"d\", \"e\"]\n\nNote that the options can be modified from the widget directly:\n\nwdg[:options][] = [\"c\", \"d\", \"e\"]\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Widgets.mask","page":"Widgets","title":"Widgets.mask","text":"mask(options; index, key)\n\nOnly display the index-th element of options. If options is a AbstractDict, it is possible to specify which option to show using key. options can be a Observable, in which case mask updates automatically. Use index=0 or key = nothing to not have any selected option.\n\nExamples\n\nwdg = mask(OrderedDict(\"plot\" => plot(rand(10)), \"scatter\" => scatter(rand(10))), index = 1)\nwdg = mask(OrderedDict(\"plot\" => plot(rand(10)), \"scatter\" => scatter(rand(10))), key = \"plot\")\n\nNote that the options can be modified from the widget directly:\n\nwdg[:options][] = [\"c\", \"d\", \"e\"]\n\n\n\n\n\n","category":"function"},{"location":"widgets/#Create-widgets-automatically-from-a-Julia-variable-1","page":"Widgets","title":"Create widgets automatically from a Julia variable","text":"","category":"section"},{"location":"widgets/#","page":"Widgets","title":"Widgets","text":"widget","category":"page"},{"location":"widgets/#Widgets.widget","page":"Widgets","title":"Widgets.widget","text":"widget(args...; kwargs...)\n\nAutomatically convert Julia types into appropriate widgets. kwargs are passed to the more specific widget function.\n\nExamples\n\nmap(display, [\n    widget(1:10),                 # Slider\n    widget(false),                # Checkbox\n    widget(\"text\"),               # Textbox\n    widget(1.1),                  # Spinbox\n    widget([:on, :off]),          # Toggle Buttons\n    widget(Dict(\"π\" => float(π), \"τ\" => 2π)),\n    widget(colorant\"red\"),        # Color picker\n    widget(Dates.today()),        # Date picker\n    widget(Dates.Time()),         # Time picker\n    ]);\n\n\n\n\n\n","category":"function"},{"location":"custom_widgets/#Custom-widgets-1","page":"Custom widgets","title":"Custom widgets","text":"","category":"section"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"Besides the standard widgets, Interact provides a framework to define custom GUIs. This is currently possible with two approaches, the full featured Widget type and the simple to use but more basic @manipulate macro.","category":"page"},{"location":"custom_widgets/#The-Widget-type-1","page":"Custom widgets","title":"The Widget type","text":"","category":"section"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"The Widget type can be used to create custom widgets. The types is parametric, with the parameter being the name of the widget and it takes as argument a OrderedDict of children.","category":"page"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"For example:","category":"page"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"d = OrderedDict(:label => \"My label\", :button => button(\"My button\"))\nw = Widget{:mywidget}(d)","category":"page"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"Children can be accessed and modified using getindex and setindex! on the Widget object:","category":"page"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"println(w[:label])\nw[:label] = \"A new label\"","category":"page"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"Optionally, the Widget can have some output, which should be an Observable:","category":"page"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"d = OrderedDict(:label => \"My label\", :button => button(\"My button\"))\noutput = map(t -> t > 5 ? \"You pressed me many times\" : \"You didn't press me enough\", d[:button])\nw = Interact.Widget{:mywidget}(d, output = output)","category":"page"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"Finally the @layout! macro allows us to set the layout of the widget:","category":"page"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"@layout! w hbox(vbox(:label, :button), observe(_)) # observe(_) refers to the output of the widget","category":"page"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"@layout!\nInteract.@layout","category":"page"},{"location":"custom_widgets/#Widgets.@layout!","page":"Custom widgets","title":"Widgets.@layout!","text":"@layout!(d, x)\n\nSet d.layout to match the result of Widgets.@layout(x). See Widgets.@layout for more information.\n\nExamples\n\njulia> using Interact\n\njulia> t = Widget{:test}(OrderedDict(:b => slider(1:100), :c => button()));\n\njulia> @layout! t hbox(:b, CSSUtil.hskip(1em), :c);\n\n\n\n\n\n","category":"macro"},{"location":"custom_widgets/#Widgets.@layout","page":"Custom widgets","title":"Widgets.@layout","text":"@layout(d, x)\n\nApply the expression x to the widget d, replacing e.g. symbol :s with the corresponding subwidget d[:s] In this context, _ refers to the whole widget. To use actual symbols, escape them with ^, as in ^(:a). @layout can be combined with @map to have the layout update interactively as function of some widget.\n\nExamples\n\njulia> using Interact\n\njulia> cpt = OrderedDict(:vertical => Observable(true), :b => slider(1:100), :c => button());\n\njulia> t = Widget{:test}(cpt, output = observe(cpt[:b]));\n\njulia> Widgets.@layout t vbox(:b, CSSUtil.vskip(1em), :c);\n\njulia> Widgets.@layout t Widgets.@map &(:vertical) ? vbox(:b, CSSUtil.vskip(1em), :c) : hbox(:b, CSSUtil.hskip(1em), :c);\n\nUse @layout! to set the widget layout in place:\n\njulia> @layout! t Widgets.@map &(:vertical) ? vbox(:b, CSSUtil.vskip(1em), :c) : hbox(:b, CSSUtil.hskip(1em), :c);\n\n@layout(x)\n\nCurried version of @layout(d, x): anonymous function mapping d to @layout(d, x).\n\n\n\n\n\n","category":"macro"},{"location":"custom_widgets/#Defining-custom-widgets-without-depending-on-Interact-1","page":"Custom widgets","title":"Defining custom widgets without depending on Interact","text":"","category":"section"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"This is only relevant for package authors: it is not necessary to depend on Interact to define custom widgets. One can instead use the low-dependency package Widgets that defines (but does not export) all the widgets. For example:","category":"page"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"# in the package MyPackage defining the recipe:\nusing Widgets\nfunction myrecipe(i)\n    label = \"My recipe\"\n    wdg = Widgets.dropdown(i)\n    Widget([\"label\" => label, \"dropdown\" => wdg])\nend\n\n# The user would then do:\nusing MyPackage, Interact\n\nmyrecipe([\"a\", \"b\", \"c\"])","category":"page"},{"location":"custom_widgets/#A-simpler-approach:-the-manipulate-macro-1","page":"Custom widgets","title":"A simpler approach: the manipulate macro","text":"","category":"section"},{"location":"custom_widgets/#","page":"Custom widgets","title":"Custom widgets","text":"@manipulate","category":"page"},{"location":"custom_widgets/#Widgets.@manipulate","page":"Custom widgets","title":"Widgets.@manipulate","text":"@manipulate expr\n\nThe @manipulate macro lets you play with any expression using widgets. expr needs to be a for loop. The for loop variable are converted to widgets using the widget function (ranges become slider, lists of options become togglebuttons, etc...). The for loop body is displayed beneath the widgets and automatically updated as soon as the widgets change value.\n\nUse throttle = df to only update the output after a small time interval dt (useful if the update is costly as it prevents multiple updates when moving for example a slider).\n\nExamples\n\nusing Colors\n\n@manipulate for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1\n    HTML(string(\"<div style='color:#\", hex(RGB(r,g,b)), \"'>Color me</div>\"))\nend\n\n@manipulate throttle = 0.1 for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1\n    HTML(string(\"<div style='color:#\", hex(RGB(r,g,b)), \"'>Color me</div>\"))\nend\n\n@layout! can be used to adjust the layout of a manipulate block:\n\nusing Interact\n\nui = @manipulate throttle = 0.1 for r = 0:.05:1, g = 0:.05:1, b = 0:.05:1\n    HTML(string(\"<div style='color:#\", hex(RGB(r,g,b)), \"'>Color me</div>\"))\nend\n@layout! ui dom\"div\"(observe(_), vskip(2em), :r, :g, :b)\nui\n\n\n\n\n\n","category":"macro"},{"location":"modifiers/#Modifiers-1","page":"Modifiers","title":"Modifiers","text":"","category":"section"},{"location":"modifiers/#","page":"Modifiers","title":"Modifiers","text":"Interact provides some modifiers to change an existing widget (or return a tranformed version of the widget):","category":"page"},{"location":"modifiers/#","page":"Modifiers","title":"Modifiers","text":"InteractBase.tooltip!\nonchange","category":"page"},{"location":"modifiers/#Widgets.tooltip!","page":"Modifiers","title":"Widgets.tooltip!","text":"tooltip!(wdg::AbstractWidget, tooltip; className = \"\")\n\nExperimental. Add a tooltip to widget wdg. tooltip is the text that will be shown and className can be used to customize the tooltip, for example is-tooltip-bottom or is-tooltip-danger.\n\n\n\n\n\n","category":"function"},{"location":"modifiers/#Widgets.onchange","page":"Modifiers","title":"Widgets.onchange","text":"onchange(w::AbstractWidget, change = w[:changes])\n\nReturn a widget that's identical to w but only updates on change. For a slider it corresponds to releasing it and for a textbox it corresponds to losing focus.\n\nExamples\n\nsld = slider(1:100) |> onchange # update on release\ntxt = textbox(\"Write here\") |> onchange # update on losing focuse\n\n\n\n\n\n","category":"function"},{"location":"layout/#Layout-1","page":"Layout","title":"Layout","text":"","category":"section"},{"location":"layout/#","page":"Layout","title":"Layout","text":"Several utilities are provided to create and align various web elements on the DOM.","category":"page"},{"location":"layout/#Example-Usage-1","page":"Layout","title":"Example Usage","text":"","category":"section"},{"location":"layout/#","page":"Layout","title":"Layout","text":"using Interact\n\nel1 =button(\"Hello world!\")\nel2 = button(\"Goodbye world!\")\n\nel3 = hbox(el1, el2) # aligns horizontally\nel4 = hline() # draws horizontal line\nel5 = vbox(el1, el2) # aligns vertically","category":"page"},{"location":"deploying/#Deploying-the-web-app-1","page":"Deploying the web app","title":"Deploying the web app","text":"","category":"section"},{"location":"deploying/#","page":"Deploying the web app","title":"Deploying the web app","text":"Interact works with the following frontends:","category":"page"},{"location":"deploying/#","page":"Deploying the web app","title":"Deploying the web app","text":"Juno - The hottest Julia IDE\nIJulia - Jupyter notebooks (and Jupyter Lab) for Julia\nBlink - An Electron wrapper you can use to make Desktop apps\nMux - A web server framework","category":"page"},{"location":"deploying/#Jupyter-notebook/lab-and-Juno-1","page":"Deploying the web app","title":"Jupyter notebook/lab and Juno","text":"","category":"section"},{"location":"deploying/#","page":"Deploying the web app","title":"Deploying the web app","text":"Simply use display:","category":"page"},{"location":"deploying/#","page":"Deploying the web app","title":"Deploying the web app","text":"using Interact\nui = button()\ndisplay(ui)","category":"page"},{"location":"deploying/#","page":"Deploying the web app","title":"Deploying the web app","text":"Note that using Interact in Jupyter Lab requires installing an extension first:","category":"page"},{"location":"deploying/#","page":"Deploying the web app","title":"Deploying the web app","text":"cd(Pkg.dir(\"WebIO\", \"assets\"))\n;jupyter labextension install webio\n;jupyter labextension enable webio/jupyterlab_entry","category":"page"},{"location":"deploying/#Electron-window-1","page":"Deploying the web app","title":"Electron window","text":"","category":"section"},{"location":"deploying/#","page":"Deploying the web app","title":"Deploying the web app","text":"To deploy the app as a standalone Electron window, one would use Blink.jl:","category":"page"},{"location":"deploying/#","page":"Deploying the web app","title":"Deploying the web app","text":"using Interact, Blink\nw = Window()\nbody!(w, ui);","category":"page"},{"location":"deploying/#Browser-1","page":"Deploying the web app","title":"Browser","text":"","category":"section"},{"location":"deploying/#","page":"Deploying the web app","title":"Deploying the web app","text":"The app can also be served in a webpage:","category":"page"},{"location":"deploying/#","page":"Deploying the web app","title":"Deploying the web app","text":"using Interact, Mux\nWebIO.webio_serve(page(\"/\", req -> ui), rand(8000:9000)) # serve on a random port","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/JuliaGizmos/Interact.jl/blob/master/docs/src/tutorial.jl\"","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This tutorial is available in the Jupyter notebook format, togeter with other example notebooks, in the doc folder. To open Jupyter notebook in the correct folder simply type:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using IJulia, Interact\nnotebook(dir = Interact.notebookdir)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"in your Julia REPL. You can also view it online here.","category":"page"},{"location":"tutorial/#Installing-everything-1","page":"Tutorial","title":"Installing everything","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To install Interact, simply type","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Pkg.add(\"Interact\")","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"in the REPL.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The basic behavior is as follows: Interact provides a series of widgets. Each widget has an output that can be directly inspected or used to trigger some callbacks (i.e. run some code as soon as the widget changes value): the abstract supertype that gives this behavior is called AbstractObservable. Let's see this in practice.","category":"page"},{"location":"tutorial/#Displaying-a-widget-1","page":"Tutorial","title":"Displaying a widget","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Interact\nui = button()\ndisplay(ui)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note that display works in a Jupyter notebook or in Atom/Juno IDE. Interact can also be deployed in Jupyter Lab, but that requires installing an extension first:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"cd(Pkg.dir(\"WebIO\", \"assets\"))\n;jupyter labextension install webio\n;jupyter labextension enable webio/jupyterlab_entry","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To deploy the app as a standalone Electron window, one would use Blink.jl:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Blink\nw = Window()\nbody!(w, ui);","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The app can also be served in a webpage via Mux.jl:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Mux\nWebIO.webio_serve(page(\"/\", req -> ui), rand(8000:9000)) # serve on a random port","category":"page"},{"location":"tutorial/#Adding-behavior-1","page":"Tutorial","title":"Adding behavior","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The value of our button can be inspected using getindex:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"ui[]","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In the case of a button, the observable represents the number of times it has been clicked: click on it and check the value again. For now however this button doesn't do anything. This can be changed by adding callbacks to it.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To add some behavior to the widget we can use the on construct. on takes two arguments, a function and an AbstractObservable. As soon as the observable is changed, the function is called with the latest value.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"on(println, ui)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"If you click again on the button you will see it printing the number of times it has been clicked so far.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Tip: anonymous function are very useful in this programming paradigm. For example, if you want the button to say \"Hello!\" when pressed, you should use:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"on(n -> println(\"Hello!\"), ui)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Tip n. 2: using the [] syntax you can also set the value of the widget:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"ui[] = 33;","category":"page"},{"location":"tutorial/#Observables:-the-implementation-of-a-widget's-output-1","page":"Tutorial","title":"Observables: the implementation of a widget's output","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The updatable container that only has the output of the widget but not the widget itself is a Observable and can be accessede using observe(ui), though it should normally not be necessary to do so. To learn more about Observables and AbstractObservable, check out their documentation here.","category":"page"},{"location":"tutorial/#What-widgets-are-there?-1","page":"Tutorial","title":"What widgets are there?","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Once you have grasped this paradigm, you can play with any of the many widgets available:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"filepicker() |> display # value is the path of selected file\ntextbox(\"Write here\") |> display # value is the text typed in by the user\nautocomplete([\"Mary\", \"Jane\", \"Jack\"]) |> display # as above, but you can autocomplete words\ncheckbox(label = \"Check me!\") |> display # value is a boolean describing whether it's ticked\ntoggle(label = \"I have read and agreed\") |> display # same as a checkbox but styled differently\nslider(1:100, label = \"To what extent?\", value = 33) |> display # value is the number selected","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"As well as the option widgets, that allow to choose among options:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"dropdown([\"a\", \"b\", \"c\"]) |> display # value is option selected\ntogglebuttons([\"a\", \"b\", \"c\"]) |> display # value is option selected\nradiobuttons([\"a\", \"b\", \"c\"]) |> display # value is option selected","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The option widgets can also take as input a dictionary (ordered dictionary is preferrable, to avoid items getting scrambled), in which case the label displays the key while the output stores the value:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"s = dropdown(OrderedDict(\"a\" => \"Value 1\", \"b\" => \"Value 2\"))\ndisplay(s)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"s[]","category":"page"},{"location":"tutorial/#Creating-custom-widgets-1","page":"Tutorial","title":"Creating custom widgets","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Interact allows the creation of custom composite widgets starting from simpler ones. Let's say for example that we want to create a widget that has three sliders and a color that is updated to match the RGB value we gave with the sliders.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"import Colors\nusing Plots\n\nfunction mycolorpicker()\n    r = slider(0:255, label = \"red\")\n    g = slider(0:255, label = \"green\")\n    b = slider(0:255, label = \"blue\")\n    output = Interact.@map Colors.RGB(&r/255, &g/255, &b/255)\n    plt = Interact.@map plot(sin, color = &output)\n    wdg = Widget([\"r\" => r, \"g\" => g, \"b\" => b], output = output)\n    @layout! wdg hbox(plt, vbox(:r, :g, :b)) ## custom layout: by default things are stacked vertically\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"And now you can simply instantiate the widget with","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"mycolorpicker()","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note the &r syntax: it means automatically update the widget as soon as the slider changes value. See Interact.@map for more details. If instead we wanted to only update the plot when a button is pressed we would do:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function mycolorpicker()\n    r = slider(0:255, label = \"red\")\n    g = slider(0:255, label = \"green\")\n    b = slider(0:255, label = \"blue\")\n    update = button(\"Update plot\")\n    output = Interact.@map (&update; Colors.RGB(r[]/255, g[]/255, b[]/255))\n    plt = Interact.@map plot(sin, color = &output)\n    wdg = Widget([\"r\" => r, \"g\" => g, \"b\" => b, \"update\" => update], output = output)\n    @layout! wdg hbox(plt, vbox(:r, :g, :b, :update)) ## custom layout: by default things are stacked vertically\nend","category":"page"},{"location":"tutorial/#A-simpler-approach-for-simpler-cases-1","page":"Tutorial","title":"A simpler approach for simpler cases","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"While the approach sketched above works for all sorts of situations, there is a specific macro to simplify it in some specific case. If you just want to update some result (maybe a plot) as a function of some parameters (discrete or continuous) simply write @manipulate before the for loop. Discrete parameters will be replaced by togglebuttons and continuous parameters by slider: the result will be updated as soon as you click on a button or move the slider:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"width, height = 700, 300\ncolors = [\"black\", \"gray\", \"silver\", \"maroon\", \"red\", \"olive\", \"yellow\", \"green\", \"lime\", \"teal\", \"aqua\", \"navy\", \"blue\", \"purple\", \"fuchsia\"]\ncolor(i) = colors[i%length(colors)+1]\nui = @manipulate for nsamples in 1:200,\n        sample_step in slider(0.01:0.01:1.0, value=0.1, label=\"sample step\"),\n        phase in slider(0:0.1:2pi, value=0.0, label=\"phase\"),\n        radii in 0.1:0.1:60\n    cxs_unscaled = [i*sample_step + phase for i in 1:nsamples]\n    cys = sin.(cxs_unscaled) .* height/3 .+ height/2\n    cxs = cxs_unscaled .* width/4pi\n    dom\"svg:svg[width=$width, height=$height]\"(\n        (dom\"svg:circle[cx=$(cxs[i]), cy=$(cys[i]), r=$radii, fill=$(color(i))]\"()\n            for i in 1:nsamples)...\n    )\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"or, if you want a plot with some variables taking discrete values:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Plots\n\nx = y = 0:0.1:30\n\nfreqs = OrderedDict(zip([\"pi/4\", \"π/2\", \"3π/4\", \"π\"], [π/4, π/2, 3π/4, π]))\n\nmp = @manipulate for freq1 in freqs, freq2 in slider(0.01:0.1:4π; label=\"freq2\")\n    y = @. sin(freq1*x) * sin(freq2*x)\n    plot(x, y)\nend","category":"page"},{"location":"tutorial/#Widget-layout-1","page":"Tutorial","title":"Widget layout","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To create a full blown web-app, you should learn the layout tools that the CSS framework you are using provides. See for example the columns and layout section of the Bulma docs. You can use WebIO to create from Julia the HTML required to create these layouts.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"However, this can be overwhelming at first (especially for users with no prior experience in web design). A simpler solution is CSSUtil, a package that provides some tools to create simple layouts.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"loadbutton = filepicker()\nhellobutton = button(\"Hello!\")\ngoodbyebutton = button(\"Good bye!\")\nui = vbox( # put things one on top of the other\n    loadbutton,\n    hbox( # put things one next to the other\n        pad(1em, hellobutton), # to allow some white space around the widget\n        pad(1em, goodbyebutton),\n    )\n)\ndisplay(ui)","category":"page"},{"location":"tutorial/#Update-widgets-as-function-of-other-widgets-1","page":"Tutorial","title":"Update widgets as function of other widgets","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Sometimes the full structure of the GUI is not known in advance. For example, let's imagine we want to load a DataFrame and create a button per column. Not to make it completely trivial, as soon as a button is pressed, we want to plot a histogram of the corresponding column.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Important note: this app needs to run in Blink, as the browser doesn't allow us to get access to the local path of a file.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We start by adding a filepicker to choose the file, and only once we have a file we want to update the GUI. this can be done as follows:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"loadbutton = filepicker()\ncolumnbuttons = Observable{Any}(dom\"div\"())","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"columnbuttons is the div object that will contain all the relevant buttons. it is an Observable as we want its value to change over time. To add behavior, we can use map!:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using CSV, DataFrames\ndata = Observable{Any}(DataFrame)\nmap!(CSV.read, data, loadbutton)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now as soon as a file is uploaded, the Observable data gets updated with the correct value. Now, as soon as data is updated, we want to update our buttons.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function makebuttons(df)\n    buttons = button.(names(df))\n    dom\"div\"(hbox(buttons))\nend\n\nmap!(makebuttons, columnbuttons, data)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We are almost done, we only need to add a callback to the buttons. The cleanest way is to do it during button initialization, meaning during our makebuttons step:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Plots\nplt = Observable{Any}(plot()) # the container for our plot\nfunction makebuttons(df)\n    buttons = button.(string.(names(df)))\n    for (btn, name) in zip(buttons, names(df))\n        map!(t -> histogram(df[name]), plt, btn)\n    end\n    dom\"div\"(hbox(buttons))\nend","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To put it all together:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using CSV, DataFrames, Interact, Plots\nloadbutton = filepicker()\ncolumnbuttons = Observable{Any}(dom\"div\"())\ndata = Observable{Any}(DataFrame)\nplt = Observable{Any}(plot())\nmap!(CSV.read, data, loadbutton)\n\nfunction makebuttons(df)\n    buttons = button.(string.(names(df)))\n    for (btn, name) in zip(buttons, names(df))\n        map!(t -> histogram(df[name]), plt, btn)\n    end\n    dom\"div\"(hbox(buttons))\nend\n\nmap!(makebuttons, columnbuttons, data)\n\nui = dom\"div\"(loadbutton, columnbuttons, plt)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"And now to serve it in Blink:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Blink\nw = Window()\nbody!(w, ui)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
